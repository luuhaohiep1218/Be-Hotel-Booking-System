const asyncHandler = require("express-async-handler");
const Room = require("../models/RoomModel");
const aqp = require("api-query-params");
const { default: mongoose } = require("mongoose");

const getListRooms = asyncHandler(async (req, res) => {
  try {
    let { filter, limit, sort, skip, population } = aqp(req.query);

    // Chuy·ªÉn ƒë·ªïi gt, gte, lt, lte th√†nh $gt, $gte, $lt, $lte ƒë·ªÉ Mongoose hi·ªÉu
    if (filter.price && typeof filter.price === "object") {
      const priceConditions = {};
      Object.keys(filter.price).forEach((key) => {
        const newKey = `$${key}`; // Chuy·ªÉn "gt" th√†nh "$gt"
        priceConditions[newKey] = Number(filter.price[key]);
      });
      filter.price = priceConditions;
    } else if (filter.price) {
      filter.price = Number(filter.price);
    }

    const rooms = await Room.find(filter)
      .limit(limit)
      .skip(skip)
      .sort(sort)
      .populate(population);

    const totalRooms = await Room.countDocuments(filter);

    res.status(200).json({ totalRooms, rooms });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: error.message || "L·ªói h·ªá th·ªëng" });
  }
});

const createRoom = asyncHandler(async (req, res) => {
  try {
    const {
      roomName,
      roomType,
      services,
      location,
      beds,
      description,
      images,
      price,
      status,
    } = req.body;

    // Ki·ªÉm tra n·∫øu thi·∫øu th√¥ng tin
    if (
      !roomName ||
      !roomType ||
      !services ||
      !location ||
      !beds ||
      !description ||
      !images ||
      !price ||
      !status
    ) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin ph√≤ng!" });
    }

    // Ki·ªÉm tra n·∫øu ph√≤ng ƒë√£ t·ªìn t·∫°i
    const existingRoom = await Room.findOne({ roomName, location });
    if (existingRoom) {
      return res
        .status(400)
        .json({ message: "Ph√≤ng n√†y ƒë√£ t·ªìn t·∫°i t·∫°i ƒë·ªãa ƒëi·ªÉm n√†y!" });
    }

    // T·∫°o ph√≤ng m·ªõi
    const newRoom = new Room({
      roomName,
      roomType,
      services,
      location,
      beds,
      description,
      images,
      price,
      status,
    });

    // L∆∞u v√†o database
    await newRoom.save();

    res.status(201).json({
      message: "T·∫°o ph√≤ng th√†nh c√¥ng!",
      room: newRoom,
    });
  } catch (error) {
    console.error("üî• L·ªói khi t·∫°o ph√≤ng:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng, vui l√≤ng th·ª≠ l·∫°i!" });
  }
});

const updateInfoRoom = asyncHandler(async (req, res) => {
  try {
    const { _id } = req.params;
    const updateData = req.body;

    console.log("D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c:", JSON.stringify(updateData, null, 2));

    // Ki·ªÉm tra ph√≤ng c√≥ t·ªìn t·∫°i kh√¥ng
    const room = await Room.findById(_id);
    if (!room) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ph√≤ng!" });
    }

    // N·∫øu c√≥ c·∫≠p nh·∫≠t roomNumber
    if (updateData.roomNumber && Array.isArray(updateData.roomNumber)) {
      // T·∫°o m·ªôt b·∫£n ƒë·ªì ƒë·ªÉ d·ªÖ d√†ng truy c·∫≠p c√°c roomNumber hi·ªán t·∫°i
      const currentRoomMap = new Map();
      room.roomNumber.forEach(rn => {
        currentRoomMap.set(rn.roomNumber.toString(), rn);
      });

      // T·∫°o m·∫£ng roomNumber m·ªõi
      const newRoomNumbers = updateData.roomNumber.map(roomNumUpdate => {
        const existingRoom = currentRoomMap.get(roomNumUpdate.roomNumber.toString());
        
        if (existingRoom) {
          // C·∫≠p nh·∫≠t roomNumber ƒë√£ t·ªìn t·∫°i
          return {
            roomNumber: roomNumUpdate.roomNumber,
            status: roomNumUpdate.status || existingRoom.status,
            isActivated: roomNumUpdate.isActivated !== undefined 
              ? roomNumUpdate.isActivated 
              : existingRoom.isActivated
          };
        } else {
          // Th√™m roomNumber m·ªõi
          return {
            roomNumber: roomNumUpdate.roomNumber,
            status: roomNumUpdate.status || "tr·ªëng",
            isActivated: roomNumUpdate.isActivated !== false
          };
        }
      });

      // C·∫≠p nh·∫≠t l·∫°i tr∆∞·ªùng roomNumber
      updateData.roomNumber = newRoomNumbers;
      
      // T√≠nh to√°n l·∫°i quantity v√† quantityLeft
      updateData.quantity = newRoomNumbers.length;
      updateData.quantityLeft = newRoomNumbers.filter(
        rn => rn.status === "tr·ªëng" && rn.isActivated
      ).length;
    }

    // S·ª≠ d·ª•ng findOneAndUpdate thay v√¨ findByIdAndUpdate ƒë·ªÉ ƒë·∫£m b·∫£o c·∫≠p nh·∫≠t ch√≠nh x√°c
    const updatedRoom = await Room.findOneAndUpdate(
      { _id: _id },
      { $set: updateData },
      {
        new: true,
        runValidators: true,
        omitUndefined: true
      }
    );

    console.log("D·ªØ li·ªáu sau khi c·∫≠p nh·∫≠t:", updatedRoom);

    res.status(200).json({
      message: "C·∫≠p nh·∫≠t th√¥ng tin ph√≤ng th√†nh c√¥ng!",
      room: updatedRoom,
    });
  } catch (error) {
    console.error("üî• L·ªói khi c·∫≠p nh·∫≠t ph√≤ng:", {
      message: error.message,
      stack: error.stack,
      details: error
    });
    res.status(500).json({ 
      message: "L·ªói h·ªá th·ªëng, vui l√≤ng th·ª≠ l·∫°i!",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
const deleteRooms = asyncHandler(async (req, res) => {
  try {
    const { roomIds } = req.body; // Nh·∫≠n danh s√°ch ID ph√≤ng c·∫ßn x√≥a

    if (!roomIds || !Array.isArray(roomIds) || roomIds.length === 0) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng cung c·∫•p danh s√°ch ph√≤ng c·∫ßn x√≥a!" });
    }

    // Ki·ªÉm tra c√°c ph√≤ng c√≥ t·ªìn t·∫°i kh√¥ng
    const existingRooms = await Room.find({ _id: { $in: roomIds } });

    if (existingRooms.length !== roomIds.length) {
      return res
        .status(404)
        .json({ message: "M·ªôt ho·∫∑c nhi·ªÅu ph√≤ng kh√¥ng t·ªìn t·∫°i!" });
    }

    // X√≥a c√°c ph√≤ng
    await Room.deleteMany({ _id: { $in: roomIds } });

    res.status(200).json({
      message: `X√≥a th√†nh c√¥ng ${existingRooms.length} ph√≤ng!`,
      deletedRooms: existingRooms,
    });
  } catch (error) {
    console.error("üî• L·ªói khi x√≥a ph√≤ng:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng, vui l√≤ng th·ª≠ l·∫°i!" });
  }
});
// l·∫•y th√¥ng tin chi ti·∫øt c·ªßa c√°c ph√≤ng 
const getRoomDetailsById = asyncHandler(async (req, res) => {
  try {
    const { roomId } = req.params;
    console.log("Received roomId:", roomId);  // Log the roomId

    if (!mongoose.Types.ObjectId.isValid(roomId)) {
      return res.status(400).json({ message: "Invalid room ID format!" });
    }

    const room = await Room.findById(roomId);
    console.log("Room found:", room);  // Log the result from the database

    if (!room) {
      return res.status(404).json({ message: "Ph√≤ng kh√¥ng t·ªìn t·∫°i!" });
    }

    res.status(200).json({
      message: "L·∫•y th√¥ng tin ph√≤ng th√†nh c√¥ng!",
      room,
    });
  } catch (error) {
    console.error("üî• L·ªói khi l·∫•y th√¥ng tin ph√≤ng:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng, vui l√≤ng th·ª≠ l·∫°i!" });
  }
});

const addReviewAndUpdateRating = asyncHandler(async (req, res) => {
  try {
    const { roomId } = req.params;
    const { comment, rating, userId } = req.body; // L·∫•y comment, rating v√† userId t·ª´ request body

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!comment || !rating || !userId) {
      return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p b√¨nh lu·∫≠n, ƒë√°nh gi√° v√† userId!" });
    }

    // T√¨m ph√≤ng theo roomId
    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ message: "Ph√≤ng kh√¥ng t·ªìn t·∫°i!" });
    }

    // Th√™m review v√†o m·∫£ng reviews c·ªßa ph√≤ng
    room.comments.reviews.push({ content: comment, rating, userId });

    // T√≠nh l·∫°i t·ªïng s·ªë b√¨nh lu·∫≠n v√† t·ªïng ƒëi·ªÉm rating
    const totalComments = room.comments.reviews.length;
    const totalRatings = room.comments.reviews.reduce((sum, review) => sum + review.rating, 0);

    // T√≠nh l·∫°i ƒëi·ªÉm trung b√¨nh (averageRating)
    const averageRating = totalRatings / totalComments;

    // C·∫≠p nh·∫≠t l·∫°i rating v√† t·ªïng b√¨nh lu·∫≠n
    room.comments.rating = averageRating.toFixed(2); // L√†m tr√≤n ƒë·∫øn 2 ch·ªØ s·ªë th·∫≠p ph√¢n
    room.comments.total = totalComments;

    // C·∫≠p nh·∫≠t starRatings array cho m·ªói rating
    room.starRatings[rating - 1] += 1; // TƒÉng s·ªë l∆∞·ª£ng ƒë√°nh gi√° cho rating t∆∞∆°ng ·ª©ng (1 sao, 2 sao, ..., 5 sao)

    // L∆∞u l·∫°i ph√≤ng v·ªõi review m·ªõi v√† c√°c gi√° tr·ªã ƒë√£ c·∫≠p nh·∫≠t
    await room.save();

    // Tr·∫£ v·ªÅ th√¥ng tin ph√≤ng ƒë√£ c·∫≠p nh·∫≠t
    res.status(200).json({
      message: "C·∫≠p nh·∫≠t b√¨nh lu·∫≠n v√† ƒë√°nh gi√° th√†nh c√¥ng!",
      averageRating: room.comments.rating, // ƒêi·ªÉm trung b√¨nh
      starRatings: room.starRatings,       // S·ªë l∆∞·ª£ng ƒë√°nh gi√° cho t·ª´ng sao
      totalComments: room.comments.total,  // T·ªïng s·ªë b√¨nh lu·∫≠n
    });
  } catch (error) {
    console.error("Error when adding review and updating rating:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng, vui l√≤ng th·ª≠ l·∫°i!" });
  }
});




module.exports = { createRoom, updateInfoRoom, deleteRooms, getListRooms, getRoomDetailsById, addReviewAndUpdateRating};
