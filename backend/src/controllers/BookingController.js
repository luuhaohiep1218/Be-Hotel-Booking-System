const asyncHandler = require("express-async-handler");
const Booking = require("../models/BookingModel");
const Service = require("../models/ServiceModel");
const Room = require("../models/RoomModel");
const bookService = asyncHandler(async (req, res) => {
  try {
    const { userId, serviceId, quantity } = req.body;

    if (!userId || !serviceId || !quantity) {
      return res.status(400).json({ message: "Thi·∫øu th√¥ng tin ƒë·∫∑t d·ªãch v·ª•" });
    }

    if (quantity < 1) {
      return res.status(400).json({ message: "S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0" });
    }

    const service = await Service.findById(serviceId);
    if (!service) {
      return res.status(404).json({ message: "D·ªãch v·ª• kh√¥ng t·ªìn t·∫°i" });
    }

    const totalPrice = service.price * quantity;

    const booking = new Booking({
      userId,
      type: "service",
      serviceId,
      quantity,
      price: totalPrice,
      status: "pending",
    });

    await booking.save();

    res.status(201).json({
      message: "ƒê·∫∑t d·ªãch v·ª• th√†nh c√¥ng",
      booking,
    });
  } catch (error) {
    console.error("L·ªói khi ƒë·∫∑t d·ªãch v·ª•:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng", error: error.message });
  }
});

const getServiceBookings = asyncHandler(async (req, res) => {
  try {
    // Parse query b·∫±ng aqp, lo·∫°i b·ªè page v√† limit kh·ªèi filter
    const { filter, sort, population } = aqp(req.query, {
      whitelist: [
        "userId",
        "serviceId",
        "status",
        "price",
        "quantity",
        "createdAt",
      ],
    });

    // Ch·ªâ l·∫•y nh·ªØng booking c√≥ type l√† "service"
    filter.type = "service";

    // L·∫•y limit & page t·ª´ query params
    const limit = parseInt(req.query.limit) || 10; // M·∫∑c ƒë·ªãnh 10 booking m·ªói trang
    const page = parseInt(req.query.page) || 1; // M·∫∑c ƒë·ªãnh trang 1
    const skip = (page - 1) * limit;

    // Truy v·∫•n danh s√°ch booking d·ªãch v·ª• c√≥ ph√¢n trang
    const totalBookings = await Booking.countDocuments(filter);
    const bookings = await Booking.find(filter)
      .sort(sort)
      .populate(population)
      .skip(skip)
      .limit(limit);

    res.status(200).json({
      totalBookings,
      totalPages: Math.ceil(totalBookings / limit),
      currentPage: page,
      limit,
      bookings,
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y danh s√°ch booking d·ªãch v·ª•:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng", error: error.message });
  }
});

 // üìå API ƒë·∫∑t ph√≤ng (book room)
const bookRoom = asyncHandler(async (req, res) => {
  try {
    const { userId, rooms, checkIn, checkOut, paymentMethod } = req.body;

    if (!userId || !rooms || rooms.length === 0 || !checkIn || !checkOut || !paymentMethod) {
      return res.status(400).json({ message: "Thi·∫øu th√¥ng tin ƒë·∫∑t ph√≤ng" });
    }

    let totalPrice = 0;
    const roomDetails = [];

    for (const { roomId, quantity } of rooms) {
      if (!roomId || quantity < 1) {
        return res.status(400).json({ message: "D·ªØ li·ªáu ph√≤ng kh√¥ng h·ª£p l·ªá" });
      }

      const room = await Room.findById(roomId);
      if (!room) {
        return res.status(404).json({ message: `Ph√≤ng ${roomId} kh√¥ng t·ªìn t·∫°i` });
      }

      totalPrice += room.price * quantity;
      roomDetails.push({ roomId, quantity });
    }

    const booking = new Booking({
      userId,
      type: "room",
      rooms: roomDetails,
      checkIn,
      checkOut,
      price: totalPrice,
      paymentMethod,
      status: "pending",
    });

    await booking.save();

    res.status(201).json({
      message: "ƒê·∫∑t ph√≤ng th√†nh c√¥ng",
      booking,
    });
  } catch (error) {
    console.error("L·ªói khi ƒë·∫∑t ph√≤ng:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng", error: error.message });
  }
});
// üìå X·ª≠ l√Ω k·∫øt qu·∫£ thanh to√°n t·ª´ VNPay
const handleVnPayReturn = asyncHandler(async (req, res) => {
  try {
    const vnpParams = req.query;

    console.log("VNPay Response:", vnpParams);

    const orderId = vnpParams.vnp_TxnRef;
    const transactionStatus = vnpParams.vnp_ResponseCode;
    const transactionId = vnpParams.vnp_TransactionNo;

    const booking = await Booking.findById(orderId);
    if (!booking) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
    }

    if (transactionStatus === "00") {
      booking.paymentStatus = "paid";
      booking.transactionId = transactionId;
      booking.status = "confirmed";
    } else {
      booking.paymentStatus = "failed";
      booking.status = "canceled";
    }

    await booking.save();

    res.status(200).json({
      message: "C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n th√†nh c√¥ng",
      booking,
    });
  } catch (error) {
    console.error("L·ªói x·ª≠ l√Ω thanh to√°n VNPay:", error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng", error: error.message });
  }
});

module.exports = { bookService,bookRoom, handleVnPayReturn, getServiceBookings };
